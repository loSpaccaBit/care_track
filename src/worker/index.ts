/// <reference lib="webworker" />

import { precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate, CacheFirst, NetworkFirst } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';
import type { Appointment } from '@/lib/types'; // Import Appointment type

declare const self: ServiceWorkerGlobalScope;

// Precache assets generated by the build process.
precacheAndRoute(self.__WB_MANIFEST);

console.log('[SW] Service Worker starting...');

// --- Caching Strategies ---

// Cache pages using NetworkFirst (try network, fallback to cache)
registerRoute(
  ({ request }) => request.mode === 'navigate',
  new NetworkFirst({
    cacheName: 'pages',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200], // Cache successful and opaque responses
      }),
      new ExpirationPlugin({
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 Days
      }),
    ],
  })
);

// Cache Google Fonts stylesheets with StaleWhileRevalidate
registerRoute(
  ({ url }) => url.origin === 'https://fonts.googleapis.com',
  new StaleWhileRevalidate({
    cacheName: 'google-fonts-stylesheets',
  })
);

// Cache Google Fonts webfont files with CacheFirst
registerRoute(
  ({ url }) => url.origin === 'https://fonts.gstatic.com',
  new CacheFirst({
    cacheName: 'google-fonts-webfonts',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxAgeSeconds: 365 * 24 * 60 * 60, // 1 Year
        maxEntries: 30,
      }),
    ],
  })
);

// Cache images with CacheFirst strategy
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 Days
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);

// Cache static assets (CSS, JS) with StaleWhileRevalidate
registerRoute(
  ({ request }) => ['style', 'script', 'worker'].includes(request.destination),
  new StaleWhileRevalidate({
    cacheName: 'static-resources',
    plugins: [
      new ExpirationPlugin({
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 Days
      }),
    ],
  })
);


// --- Push Notification Handling ---

// NOTE: Scheduling notifications precisely (e.g., "10 minutes before") using only
// client-side mechanisms (like setTimeout in a Service Worker) is inherently unreliable,
// especially on mobile operating systems (iOS, Android) which aggressively manage background processes.
// The Service Worker might be terminated before the timeout completes.
// The most reliable approach requires a backend server to send push messages at the appropriate time.
// The code below implements the client-side `setTimeout` approach as requested, but be aware of its limitations.

// Store setTimeout IDs to attempt cancellation.
const scheduledNotificationTimeouts: Map<string, number> = new Map(); // Map tag -> timeoutId

// Function to clear previously scheduled notifications using stored timeout IDs
const clearScheduledNotifications = async () => {
    console.log('[SW] Clearing previously scheduled timeouts...');
    scheduledNotificationTimeouts.forEach((timeoutId, tag) => {
        console.log(`[SW] Clearing timeout for tag: ${tag}`);
        clearTimeout(timeoutId);
    });
    scheduledNotificationTimeouts.clear();

    // Also close any *visible* notifications that might have been scheduled by us
    try {
        const notifications = await self.registration.getNotifications();
        notifications.forEach(notification => {
            if (notification.tag && notification.tag.startsWith('appointment-')) {
                console.log(`[SW] Closing visible notification with tag: ${notification.tag}`);
                notification.close();
            }
        });
    } catch (error) {
         console.error('[SW] Error getting or closing existing notifications:', error);
    }
};

// Listen for messages from the client (main app thread)
self.addEventListener('message', (event) => {
    if (event.data && event.data.type === 'SCHEDULE_APPOINTMENTS') {
        console.log('[SW] Received appointments to schedule notifications for:', event.data.payload);
        const appointments: Appointment[] = event.data.payload;
        // Clear existing scheduled timeouts before scheduling new ones
        clearScheduledNotifications().then(() => {
            scheduleAppointmentNotifications(appointments);
        });
    } else if (event.data && event.data.type === 'CLEAR_NOTIFICATIONS') {
        clearScheduledNotifications();
    }
});

const scheduleAppointmentNotifications = (appointments: Appointment[]) => {
    const now = Date.now();
    const tenMinutesInMillis = 10 * 60 * 1000;

    appointments.forEach(appointment => {
        // Only schedule for appointments that are upcoming today, not completed, and have a specific time
        if (!appointment.isCompleted && appointment.time && appointment.time !== 'N/D' && appointment.date) {
            const [hours, minutes] = appointment.time.split(':').map(Number);
            if (isNaN(hours) || isNaN(minutes)) {
                console.warn(`[SW] Invalid time format for appointment ${appointment.id}: ${appointment.time}`);
                return;
            }

            // Create a Date object for the appointment time today
            const appointmentDate = new Date(appointment.date); // Date should be correct from fetch
             // Ensure the date object uses the local timezone when setting time
            const today = new Date(); // Reference for today's date parts
            appointmentDate.setFullYear(today.getFullYear());
            appointmentDate.setMonth(today.getMonth());
            appointmentDate.setDate(today.getDate());
            // Now set the time
            appointmentDate.setHours(hours, minutes, 0, 0);

            const appointmentTime = appointmentDate.getTime();
            const notificationTime = appointmentTime - tenMinutesInMillis;

            // Only schedule if the notification time is in the future
            if (notificationTime > now) {
                const delay = notificationTime - now;
                // Use a tag that includes appointment ID and the specific notification time
                const notificationTag = `appointment-${appointment.id}-${notificationTime}`;

                // Avoid rescheduling if a timeout for this exact tag already exists
                if (scheduledNotificationTimeouts.has(notificationTag)) {
                    console.log(`[SW] Notification already scheduled for tag: ${notificationTag}. Skipping.`);
                    return;
                }

                console.log(`[SW] Scheduling notification for ${appointment.patientName} at ${appointment.time} (10 min before). Trigger time: ${new Date(notificationTime).toISOString()}. Delay: ${delay}ms`);

                // --- Using setTimeout (Unreliable on Mobile) ---
                const timeoutId = setTimeout(() => {
                    console.log(`[SW] Timeout triggered for tag: ${notificationTag}. Showing notification.`);
                    const options: NotificationOptions = {
                        body: `Appuntamento con ${appointment.patientName} alle ${appointment.time}.`,
                        icon: '/icons/icon-192x192.png',
                        badge: '/icons/badge-72x72.png', // Optional: for Android status bar
                        tag: notificationTag, // Unique tag per scheduled instance
                        timestamp: notificationTime, // Show the intended trigger time
                        renotify: true, // Re-alert user even if tag matches a previous *closed* notification
                        data: {
                            url: `/patient/${appointment.patientId}` // URL to open on click
                        },
                        requireInteraction: true, // Keep notification until dismissed (helps visibility)
                    };
                    self.registration.showNotification(`Appuntamento tra 10 minuti`, options)
                        .then(() => {
                             console.log(`[SW] Notification shown for tag: ${notificationTag}`);
                        })
                        .catch(err => {
                             console.error(`[SW] Error showing notification for tag ${notificationTag}:`, err);
                        });

                    // Remove from tracking map after timeout fires
                    scheduledNotificationTimeouts.delete(notificationTag);
                }, delay) as unknown as number; // Cast to number for storage

                // Store the timeout ID with the tag
                scheduledNotificationTimeouts.set(notificationTag, timeoutId);

            } else {
                console.log(`[SW] Skipping past or immediate appointment: ${appointment.patientName} at ${appointment.time}`);
            }
        } else {
             // Log why an appointment wasn't scheduled
             if (appointment.isCompleted) console.log(`[SW] Skipping completed appointment: ${appointment.patientName}`);
             if (!appointment.time || appointment.time === 'N/D') console.log(`[SW] Skipping appointment without specific time: ${appointment.patientName}`);
             // If date is not today, it wouldn't be in the list based on HomePage logic, but good to be defensive
             // if (appointment.date && !isSameDay(appointment.date, new Date())) console.log(`[SW] Skipping appointment not for today: ${appointment.patientName}`);
        }
    });
     console.log(`[SW] Scheduling complete. Total timeouts stored: ${scheduledNotificationTimeouts.size}`);
};


// Standard Push Event Handler (for externally triggered pushes from a server)
self.addEventListener('push', (event) => {
  console.log('[SW] Push Received.');
  if (!event.data) {
    console.error('[SW] Push event but no data');
    return;
  }
  const rawData = event.data.text();
  console.log(`[SW] Push data: "${rawData}"`);

  let data = { title: 'Nuova Notifica', body: 'Qualcosa è accaduto!', tag: 'default', url: '/' };
  try {
    // Attempt to parse JSON data from the push payload
    const parsedData = JSON.parse(rawData);
    // Merge parsed data with defaults, giving preference to parsed data
    data = { ...data, ...parsedData };
  } catch (e) {
    // If JSON parsing fails, use the raw text as the body
    data.body = rawData;
    console.warn('[SW] Push data was not valid JSON, using raw text as body.');
  }

  const options: NotificationOptions = {
    body: data.body,
    icon: '/icons/icon-192x192.png', // Main icon
    badge: '/icons/badge-72x72.png', // Optional: small icon for status bar (Android)
    tag: data.tag, // Group notifications or replace previous ones with the same tag
    data: { // Custom data to pass to the notification click event
        url: data.url // URL to navigate to on click
    },
    requireInteraction: true, // Keep notification visible until user interaction
    renotify: true, // Vibrate/alert even if a notification with the same tag exists (but was closed)
    // actions: [ // Example actions (consider adding relevant ones)
    //   { action: 'view', title: 'Vedi Dettagli' },
    //   { action: 'dismiss', title: 'Ignora' }
    // ]
  };

  // Ensure the notification is shown before the service worker potentially terminates
  event.waitUntil(self.registration.showNotification(data.title, options));
});

// Handle Notification Clicks
self.addEventListener('notificationclick', (event) => {
  console.log('[SW] Notification click Received.', event.notification.tag);

  event.notification.close(); // Close the notification that was clicked

  // Handle notification actions if defined
  if (event.action === 'dismiss') {
    console.log('[SW] Dismiss action clicked.');
    return;
  }
  if (event.action === 'view') {
      console.log('[SW] View action clicked.');
      // Optionally modify urlToOpen based on the action
  }


  const urlToOpen = event.notification.data?.url || '/'; // Get URL from data or default to homepage

  // Ensure the browser focuses or opens the correct window/tab
  event.waitUntil(
    clients.matchAll({
      type: 'window',
      includeUncontrolled: true, // Important for PWAs
    }).then((clientList) => {
      // Check if a window/tab with the target URL is already open
      const targetUrl = new URL(urlToOpen, self.location.origin); // Ensure target URL is absolute

      for (const client of clientList) {
        const clientUrl = new URL(client.url);
        // More robust check: Compare origin and pathname. Adjust if query params/hash matter.
        if (clientUrl.origin === targetUrl.origin && clientUrl.pathname === targetUrl.pathname && 'focus' in client) {
          console.log('[SW] Focusing existing client:', client.url);
          return client.focus(); // Focus the existing window/tab
        }
      }
      // If no existing window/tab is found, open a new one
      if (clients.openWindow) {
        console.log('[SW] Opening new window:', urlToOpen);
        return clients.openWindow(urlToOpen);
      }
    })
  );
});

// Optional: Listen for subscription changes (e.g., user revokes permission externally)
self.addEventListener('pushsubscriptionchange', (event) => {
  console.log('[SW] Push subscription changed. Need to re-subscribe or notify server.');
  // IMPORTANT: You need a strategy here.
  // Option 1: Try to re-subscribe automatically (might fail if permission is now denied).
  // Option 2: Send information to your backend that the subscription is invalid.
  // Example (Conceptual - requires subscribeUserToPush function availability):
  // event.waitUntil(subscribeUserToPush().catch(err => console.error('Failed to re-subscribe on change:', err)));
});

// Service Worker Lifecycle
self.addEventListener('install', () => {
    console.log('[SW] Install event');
    // Force the waiting service worker to become the active service worker.
    self.skipWaiting();
});

self.addEventListener('activate', (event) => {
    console.log('[SW] Activate event');
    // Take control of all pages under this SW's scope immediately.
    event.waitUntil(clients.claim().then(() => {
        // Clear any previously scheduled notifications on activation
        // to prevent potential duplicates if the SW was terminated and restarted.
        console.log('[SW] Claimed clients. Clearing any existing scheduled notifications.');
        return clearScheduledNotifications();
    }));
});

console.log('[SW] Service Worker script loaded.');
```